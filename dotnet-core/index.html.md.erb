---
title: .NET Core Buildpack
owner: Buildpacks
---

<strong><%= modified_date %></strong>

This topic describes how to push Cloud Foundry apps using the .NET Core buildpack. You can find supported ASP.NET Core versions in the [.NET Core buildpack release notes](https://github.com/cloudfoundry/dotnet-core-buildpack/releases).

## <a id='requirements'></a>Requirements

You can deploy .NET Core apps to either a Windows stack or a Linux stack.

To deploy a .NET Core app to a Linux stack, use the [.NET Core](../dotnet-core/index.html) buildpack pushed to cflinuxfs2 or cflinuxfs3.

To deploy a .NET Core app to a Windows stack, build it as a self-contained app and push it with the [Binary](../binary/index.html) buildpack, specifying the Windows 2016 stack with a custom start command.

<%= vars.product_full %> automatically uses the .NET Core buildpack when one or more of the following conditions are met:

- The pushed app contains one or more `*.csproj` or `*.fsproj` files.
- The pushed app contains one or more `project.json` files.
- The app is pushed from the output directory of the `dotnet publish` command.

For .NET Console apps and Windows executables, use the [Binary](../binary/index.html) buildpack.

For ASP.NET MVC, ASP.NET Web Forms, ASP.NET WebAPI, and Windows Communication Foundation (WCF) apps, use the [HWC](../hwc/index.html) buildpack.

## <a id='pushing-apps'></a> Push an App ##

Follow the steps below to push your application.

<table border='1' class='nice'>
<tr>
<th>Step</th>
<th>Action</th>
</tr>
<tr valign="top">
  <td>1.</td>
  <td>(Optional) Specify any non-default package sources in the <code>NuGet.Config</code> file.</td>
</tr>
<tr valign="top">
  <td>2.</td>
  <td>Use the <code>cf push APP_NAME</code> command to push your app. Replace <code>APP_NAME</code> with the name you want to give your application. For example:<br>
<pre class='terminal'>
$ cf push my-app
Creating app my-app in org sample-org / space sample-space as username@example.com...
OK
â€¦
requested state: started
instances: 1/1
usage: 1GB x 1 instances
urls: my-app.example.com
</pre>
If your <%= vars.product_full %> deployment does not have the .NET Core buildpack installed or the installed version is out of date, push your app with the <code>-b</code> option to specify the buildpack:
<pre class="terminal">
$ cf push MY-APP -b https://github.com/cloudfoundry/dotnet-core-buildpack.git
</pre>
  </td>
</tr>
<tr valign="top">
  <td>3.</td>
  <td>Find the URL of your app in the output from the push command and navigate to it to see your HWC app running.</td>
</tr>
</table>



For a basic example, see this [Hello World sample](https://github.com/IBM-Bluemix/aspnet-core-helloworld).

## <a id='cli-tools'></a> .NET Core SDKs ##

The first several releases of the .NET Core SDKs used `project.json` files for project build configuration. The current release of the .NET Core SDK uses MSBuild as its build tool, which uses `*.csproj` and `*.fsproj` files for configuration.

Currently, the .NET Core buildpack includes both types of SDKs. If the pushed app contains a `global.json` file, the buildpack installs the version specified by that file. Otherwise, the buildpack chooses which SDK to install as follows:

1. If the app only contains `project.json` files, the buildpack installs the latest SDK that supports this configuration.
2. If the app only contains `*.csproj` and `*.fsproj` files, the buildpack installs the latest SDK that uses MSBuild.
3. If the app contains both file types without a `global.json`, the buildpack throws an error, as it cannot determine the proper SDK to install.

<p class="note"><strong>Note</strong>: Microsoft has removed support for project.json from the <a href="https://blogs.msdn.microsoft.com/dotnet/2016/11/16/announcing-net-core-tools-msbuild-alpha/">.NET Core SDK tools</a>. Consequently, support for <code>project.json</code> apps in the buildpack will soon be deprecated.
</p>

## <a id='port'></a>Configure the Listen Port ##

For your .NET Core app to work on Cloud Foundry, you must modify the `Main` method to configure the app to listen on the port specified by the `$PORT` environment variable, which Cloud Foundry sets automatically.

1. Open the file that contains your `Main` method.

1. Add a `using` statement to the top of the file.

    ```c#
    using Microsoft.Extensions.Configuration;
    ```

1. Add the following lines before the line `var host = new WebHostBuilder()`:

    ```c#
    var config = new ConfigurationBuilder()
        .AddCommandLine(args)
        .Build();
    ```
1. Add the following line after `.UseKestrel()`:

    ```c#
    .UseConfiguration(config)
    ```

    This allows the buildpack to pass the correct port from `$PORT` to the app when running the initial startup command.




1. Add `Microsoft.Extensions.Configuration.CommandLine` as a dependency using one of the following:
    - `project.json`:

		```json
        "Microsoft.Extensions.Configuration.CommandLine": "VERSION",
        ```
    - `*.csproj`:

        ```xml
        <PackageReference Include="Microsoft.Extensions.Configuration.CommandLine">
            <Version>VERSION</Version>
        </PackageReference>
        ```

    Where `VERSION` is the version of the package to use. Valid versions can be found on `https://www.nuget.org`.

1. If your app requires any other files at runtime, such as JSON configuration files, add them to the `include` section of `copyToOutput`.

1. Save your changes.

With these changes, the `dotnet run` command copies your app `Views` to the build output, where the .NET CLI can find them. Refer to the following example `Main` method:

```c#
public static void Main(string[] args)
{
    var config = new ConfigurationBuilder()
        .AddCommandLine(args)
        .Build();

    var host = new WebHostBuilder()
        .UseKestrel()
        .UseConfiguration(config)
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseStartup<Startup>()
        .Build();
    host.Run();
}
```

## <a id='specify-version'></a>Specify a .NET Framework Version ##

Lock the .NET Framework to a minor version. Do not lock to a patch version, because
buildpacks contain only the two most recent patch versions of each minor version.

To lock the .NET Framework version in a `.csproj` app:

```
  <ItemGroup>
    <PackageReference Include="Microsoft.NETCore.App">
      <Version>1.1.*</Version>
    </PackageReference>
  </ItemGroup>
```

To lock the .NET Framework version in a `project.json` app:

```
  "dependencies": {
    "Microsoft.NETCore.App": {
      "type": "platform",
      "version": "1.0.*"
    }
  }
```

## <a id='multiple-projects'></a>Deploy Apps with Multiple Projects ##

To deploy an app that contains multiple projects, you must specify a main project for the buildpack to run. Create a `.deployment` file in the root folder of the app which sets the path to the main project as follows:

```text
[config]
project = <main project>
```

1. If the app uses `project.json`, set `project` to the directory containing the `project.json` file of the main project.

2. If the app uses MSBuild, set `project` to the `*.csproj` or `*.fsproj` file of the main project.

For example, if an app using MSBuild contains three projects in the `src` folder, the main project `MyApp.Web`, `MyApp.DAL`, and `MyApp.Services`, format the `.deployment` file as follows:

```text
[config]
project = src/MyApp.Web/MyApp.Web.csproj
```

In this example, the buildpack automatically compiles the `MyApp.DAL` and `MyApp.Services` projects if the `MyApp.Web.csproj` file of the main project lists them as dependencies, `MyApp.Web`. The buildpack attempts to execute the main project with `dotnet run -p src/MyApp.Web/MyApp.Web.csproj`.

## <a id='disconnected-environments'></a>Push an App in a Disconnected Environment ##

For offline use, you can cache the binaries in `manifest.yml` with the buildpack.

You can push apps with their other dependencies following these steps:

1. Publish the app by running `dotnet publish -r ubuntu.14.04-x64`.

    <p class="note"><strong>Note</strong>: For this publish command to work, modify your app code so the .NET CLI publishes it as a self-contained app. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/articles/core/deploying/">.NET Core Application Deployment</a>.
    </p>

1. Navigate to the `bin/<Debug|Release>/<framework>/<runtime>/publish` directory. Or, if your app uses a `manifest.yml`, specify a path to the publish output folder. This allows you to push your app from any directory.

1. Push your app.

## <a id='disabling-nuget'></a>Disabling the NuGet Package Cache

You may need to disable NuGet package caching, or clear NuGet packages cached in the staging environment, in one of the following scenarios:

* Your app fails to stage because it runs out of space, exceeding the maximum allowable disk quota.
* You have added pre-release packages to test a new feature, then decided to revert back to the main NuGet feed. You may need to remove the packages you changed from the cache to avoid conflicts.

Disabling NuGet caching both clears any existing NuGet dependencies from the staging cache and prevents the buildpack from adding NuGet dependencies to the staging cache.

To disable NuGet package caching, set the `CACHE_NUGET_PACKAGES` environment variable to `false`. If the variable is not set, or set to a different value, there is no change. Perform one of the following procedures to set `CACHE_NUGET_PACKAGES` to `false`:

* Locate your app manifest, `manifest.yml`, and set the `CACHE_NUGET_PACKAGES` environment variable, following the format of the example below:

    ```yml
    ---
    applications:
    - name: sample-aspnetcore-app
      memory: 512M
      env:
        CACHE_NUGET_PACKAGES: false
    ```

* Use `cf set-env` to set the `CACHE_NUGET_PACKAGES` environment variable on the command line:

    <pre class="terminal">$ cf set-env YOUR-APP CACHE_NUGET_PACKAGES false</pre>

See the [Environment Variables](../../devguide/deploy-apps/manifest.html#env-block) section of the <em>Deploying with Application Manifests</em> topic for more information.

## <a id='custom-libraries'></a>Add Custom Libraries ##

If your app requires external shared libraries that are not provided by the rootfs or the buildpack, you must place the libraries in an `ld_library_path` directory at the app root.

<p class="note"><strong>Note</strong>: You must keep these libraries up-to-date. They do not update automatically.</p>

The .NET Core buildpack automatically adds the directory `<app-root>/ld_library_path` to `LD_LIBRARY_PATH` so that your app can access these libraries at runtime.
